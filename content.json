{"meta":{"title":"Li ' s Blog","subtitle":"写字的地方","description":"写写字","author":"李子灿","url":"https://banatech.org","root":"/"},"pages":[{"title":"","date":"2022-05-08T12:01:16.605Z","updated":"2022-05-08T12:01:16.593Z","comments":true,"path":"tags/index.html","permalink":"https://banatech.org/tags/index.html","excerpt":"","text":""},{"title":"","date":"2022-05-08T12:03:04.514Z","updated":"2022-05-08T12:03:04.501Z","comments":true,"path":"categories/index.html","permalink":"https://banatech.org/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"MapReduce:\\\\ 大型集群上的简化数据处理\\(论文翻译\\)","slug":"MapReduce","date":"2022-05-29T12:14:07.000Z","updated":"2022-05-29T12:16:02.902Z","comments":true,"path":"20220529/c3f5f361cc76.html","link":"","permalink":"https://banatech.org/20220529/c3f5f361cc76.html","excerpt":"","text":"MapReduce: Simplifified Data Processing on Large Clusters MapReduce: 大型集群上的简化数据处理 Abstract 抽象 MapReduce is a programming model and an associated implementation for processing and generating large data sets. Users specify a map function that processes a key&#x2F;value pair to generate a set of intermediate key&#x2F;value pairs, and a reduce function that merges all intermediate values associated with the same intermediate key. Many real world tasks are expressible in this model, as shown in the paper. MapReduce是一种编程模式和用于处理和生成大型数据集相关的实现,用户指定一个用于处理一个键值对和以及生成一组中间键值对的map函数,以及一个用于合并与同一中间键关联的所有中间值的reduce 函数。如论文所示，该模型可以表达许多现实世界的任务. Programs written in this functional style are automatically parallelized and executed on a large cluster of commodity machines. The run-time system takes care of the details of partitioning the input data, scheduling the program’s execution across a set of machines, handling machine failures, and managing the required inter-machine communication. This allows programmers without any experience with parallel and distributed systems to easily utilize the resources of a large distributed system. 通过函数式编程编写的程序会自动并行化的大型商业集群上执行,运行时系统负责对输入的数据进行拆分、在一组机器上调度程序执行，处理机器故障以及管理所需的机器间通信等细节，这使得程序员无需任何并行和分布式经验就可以轻松的利用大型分布式系统的资源。","categories":[],"tags":[]},{"title":"使用Golang从零实现一个简易Web框架","slug":"lee-go","date":"2022-05-18T15:01:43.000Z","updated":"2022-05-18T15:08:07.073Z","comments":true,"path":"20220518/f9010c4d8c98.html","link":"","permalink":"https://banatech.org/20220518/f9010c4d8c98.html","excerpt":"","text":"序言很多时候当我们需要实现一个web应用，第一时间想到的就是去使用哪个框架,然而不同的框架有不同的设计理念,提供的功能也有很大的差别 ,比如Java的Spring ,Python的flask 、django ,Go的 Beego、Gin 、Iris 等。那我们为什么不直接使用语言提供的标准库编写呢？要回答这个问题，首先明白框架的核心应该为我们提供什么？ 为什么要用框架？ 只有理解这些才能知道我们在框架中需要实现那些功能。为了深入理解Gin框架的代码和设计。本项目将会参考Gin框架实现Gin框架中部分的功能,学习一门技术最好的方式就是看懂后自己去实现一遍。Gin框架的代码一共约1万4千行，其中测试代码9千行，也就是说实际代码只有5千行, 小而美。非常值得初学者去学习。 代码仓库: https://github.com/xiaocan66/lee_go 目前已实现的功能 动态路由 路由分组 添加中间件 HTML模板 数据映射 开发中….. 功能演示开启一个HTTP服务12345678910package mainimport &quot;lee&quot;func main()&#123; r := lee.Default() r.Get(&quot;/&quot;, func(ctx *lee.Context) &#123; fmt.Fprint(ctx.Writer, &quot;Hello world&quot;) &#125;) r.Run(&quot;:9000&quot;) &#125; 使用中间件12345678910111213141516171819202122package mainimport &quot;lee&quot;// auth 定义中间件逻辑func auth() lee.HandlerFunc &#123; return func(ctx *lee.Context) &#123; username := ctx.Query(&quot;username&quot;) if username == &quot;lee&quot; &#123; ctx.Next() &#125; ctx.Abort() &#125;&#125;func main()&#123; r := lee.Default() r.Use(auth()) // 使用中间件 r.Get(&quot;/&quot;, func(ctx *lee.Context) &#123; fmt.Fprint(ctx.Writer, &quot;Hello world&quot;) &#125;) r.Run(&quot;:9000&quot;) &#125; 动态路由1234567891011func main()&#123; r := lee.Default() r.Use(auth()) // 使用中间件 r.Get(&quot;/user/:username&quot;, func(ctx *lee.Context) &#123; fmt.Fprint(ctx.Writer, &quot;Hello world&quot;) &#125;) r.Get(&quot;/assets/*filepath&quot;, func(ctx *lee.Context) &#123; fmt.Fprint(ctx.Writer, &quot;Hello world&quot;) &#125;) r.Run(&quot;:9000&quot;) &#125; 路由分组12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport &quot;lee&quot;// auth 定义中间件逻辑func auth() lee.HandlerFunc &#123; return func(ctx *lee.Context) &#123; username := ctx.Query(&quot;username&quot;) if username == &quot;lee&quot; &#123; ctx.Next() &#125; ctx.Abort() &#125;&#125;func auth2() lee.HandlerFunc &#123; return func(ctx *lee.Context) &#123; username := ctx.Query(&quot;username&quot;) if username == &quot;lee2&quot; &#123; ctx.Next() &#125; ctx.Abort() &#125;&#125;func main()&#123; r := lee.Default() r.Get(&quot;/&quot;, func(ctx *lee.Context) &#123; fmt.Fprint(ctx.Writer, &quot;Hello world&quot;) &#125;) g1 := r.Group(&quot;v1&quot;) g1.Use(auth()) g1.Get(&quot;/user&quot;, func(ctx *lee.Context) &#123; fmt.Fprint(ctx.Writer, &quot;g1&quot;) &#125;) g2 := r.Group(&quot;v2&quot;) g2.Use(auth2()) g2.Get(&quot;/post&quot;, func(ctx *lee.Context) &#123; fmt.Fprint(ctx.Writer, &quot;g2&quot;) &#125;) r.Run(&quot;:9000&quot;)&#125;","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://banatech.org/tags/Go/"}]}],"categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://banatech.org/tags/Go/"}]}